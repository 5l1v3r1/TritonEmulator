#!/usr/bin/env python
# coding=utf-8

"""
Module name: Exploiter.py
Create by:   Bluecake
Description: Basic class for automatic exploitation
"""

import os
from pwn import * 
from triton import OPCODE, Instruction
import logging
from emulator import *
from solver import *
import crash


"""
A basic class for exploitation framework.
Provide basic functions for higher level exploitation
"""
class Exploiter(object):

    def __init__(self, binary, crashfile, log_level=logging.DEBUG):

        self.binary = binary
        self.crashfile = crashfile
        self.log_level = log_level

        self.crashType = None
        self.log = get_logger('exploiter.py', log_level)
        
        self.src = []
    

    """
    New and init an emulator
    """
    def initEmulator(self, show_inst=False, symbolize=False, isTaint=False):

        emulator = Emulator(self.binary, 
                show_inst=show_inst, 
                show_output=False,
                symbolize=symbolize, 
                isTaint=isTaint, 
                log_level=self.log_level)

        emulator.initialize()

        # create pipe for SYSCALL read
        emulator.read, emulator.write = os.pipe()
        with open(self.crashfile, 'rb') as f:
            data = f.read()
            os.write(emulator.write, data + '\n')
        
        return emulator

    
    """
    Get crash type. Supported type includes:
        NO_CRASH, not any type of crash
        CONTROL_PC, pc address can be control by input
        SHELLCODE, is able to execute inputed shellcode
    """
    def getCrashType(self):

        if self.crashType:
            return self.crashType

        emulator = self.initEmulator()
        pc = emulator.getpc()

        try:
            while pc:
                pc = emulator.process()
            self.crashType = crash.NO_CRASH

        except IllegalPcException:
            self.log.info("Detecting crash info at " + hex(pc))
            self.read_record = emulator.read_record 
            self.crash_pc = pc
            esp = emulator.getreg('esp') - 4
            self.dst = range(esp, esp + 4)
            self.crashType = crash.CONTROL_PC

        except IllegalInstException:
            self.crashType = crash.SHELLCODE

        return self.crashType
    

    """
    Generate map of address of memory stored input
    """
    def getSrc(self):

        if not self.src:
            for rc in self.read_record:
                start = rc[0]
                length = rc[1]
                self.src.extend(range(start, start + length))

        return self.src 
        

    """
    Get the list of memory address which cause program crash
    """
    def getCrashMemory(self):
        return self.dst


    """
    
    """
    def getControlMemory(self):
        pass

    """

    """
    def getControlShellcode(self):
        pass


    """
    Create input stream with solve answer
    """
    def createInput(self, answer, blank='a'):
        
        inputBuffer = ''
        for addr in self.src:
            if answer.has_key(addr):
                inputBuffer += answer[addr]
            else:
                inputBuffer += blank

        return inputBuffer


    """
    Create input stream which can control eip to target value
    """
    def pcPayload(self, pc):

        if self.crashType != crash.CONTROL_PC:
            return False
        
        initInput = open(self.crashfile).read()
        solver = InputSolver(self.binary, self.getSrc(), self.crash_pc, initInput)
        answer = solver.solveValue(self.dst, pc)
        
        return answer
