#!/usr/bin/env python
# coding=utf-8

"""
Module name: Exploiter.py
Create by:   Bluecake
Description: Basic class for automatic exploitation
"""

import os
from pwn import u32, asm, context
from triton import OPCODE, Instruction
from emulator import *
import crash

"""
A basic class for exploitation framework.
Provide basic functions for higher level exploitation
"""
class Exploiter(object):

    def __init__(self, binary, crashfile):

        self.binary = binary
        self.crash = crashfile
        self.crashType = None
        self.log = get_logger('exploiter.py', logging.DEBUG)

    
    """
    New and init an emulator
    """
    def initEmulator(self, show=False, symbolize=False, isTaint=False):

        emulator = Emulator(self.binary, show=show, symbolize=symbolize, isTaint=isTaint)
        emulator.initialize()

        # create pipe for SYSCALL read
        emulator.read, emulator.write = os.pipe()
        with open(self.crash, 'rb') as f:
            data = f.read()
            os.write(emulator.write, data + '\n')
        
        return emulator

    
    """
    Get crash type. Supported type includes:
        NO_CRASH, not any type of crash
        CONTROL_PC, pc address can be control by input
        SHELLCODE, is able to execute inputed shellcode
    """
    def getCrashType(self):

        if self.crashType:
            return self.crashType

        emulator = self.initEmulator()
        pc = emulator.getpc()

        try:
            while pc:
                pc = emulator.process()
            self.crashType = crash.NO_CRASH

        except IllegalPcException:
            self.log.info("Detecting crash info at " + hex(pc))
            self.read_record = emulator.read_record 
            self.crash_pc = pc
            esp = emulator.getreg('esp') - 4
            self.dst = range(esp, esp + 4)
            self.crashType = crash.CONTROL_PC

        except IllegalInstException:
            self.crashType = crash.SHELLCODE

        del emulator
        return self.crashType

        

    """
    Get the list of memory address which cause program crash
    """
    def getCrashMemory(self):
        return self.dst


    """
    
    """
    def getControlMemory(self):
        pass

    """

    """
    def getControlShellcode(self):
        pass


    """
    Inner method for traceMemory()
    """
    def _traceMemory(self, src, dst):
        
        if len(src) == 1:
            return src

        left = src[ : len(src)/2]
        right = src[len(src)/2 : ]
        
        emulator = self.initEmulator(isTaint=True)
        emulator.taintable = left

        pc = emulator.getpc()
        while pc != self.crash_pc:
            pc = emulator.process()

        if emulator.isTainted(dst):
            new_left = self._traceMemory(left, dst)
        else:
            new_left = []

        emulator = self.initEmulator(isTaint=True)
        emulator.taintable = right

        pc = emulator.getpc()
        while pc != self.crash_pc:
            pc = emulator.process()
            
        if emulator.isTainted(dst):
            new_right = self._traceMemory(right, dst)
        else:
            new_right = []

        return new_left + new_right


    """
    Track source input of memory content
    """
    def traceMemory(self, dst):

        src = []
        for rc in self.read_record:
            start = rc[0]
            length = rc[1]
            src.extend(range(start, start + length))
        
        source = self._traceMemory(src, dst)
        return source


    """
    Get input data with expected value
    """ 
    def solveValue(self, mem, value):
        """
        Arguments:
            mem, address list of target memory we want to solve
            value, value list of target memory we expect to be
        """

        if len(mem) != len(value):
            print "Mem and value length is not equal, please checkout"
            return False

        symbolized = self.traceMemory(mem)

        if not symbolized:
            return False
        
        emulator = self.initEmulator(symbolize=True)
        emulator.symbolized = symbolized

        pc = emulator.getpc()
        while pc != self.crash_pc:
            pc = emulator.process()
         
        Triton = emulator.triton
        astCtxt = Triton.getAstContext()
        constraints = [Triton.getPathConstraintsAst()]
        
        for i, v in enumerate(value):
            mem_id = Triton.getSymbolicMemoryId(mem[i])
            mem_sym = Triton.getSymbolicExpressionFromId(mem_id)
            mem_ast = mem_sym.getAst()
            constraints.append(astCtxt.equal(mem_ast, astCtxt.bv(value[i], 8)))

        cstr  = astCtxt.land(constraints)
        print '[+] Asking for a model, please wait...'
        model = Triton.getModel(cstr)
        new_input = {}
        for k, v in model.items():
            print '[+]', v
            index = int(v.getName().replace('SymVar_', ''))
            new_input[symbolized[index]] = chr(v.getValue())
        
        return new_input
