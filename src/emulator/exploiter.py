#!/usr/bin/env python
# coding=utf-8

"""
Module name: Exploiter.py
Create by:   Bluecake
Description: Basic class for automatic exploitation
"""

import os
from pwn import * 
from triton import OPCODE, Instruction
import logging
from emulator import *
from solver import *
import crash


"""
A basic class for exploitation framework.
Provide basic functions for higher level exploitation
"""
class Exploiter(object):

    def __init__(self, binary, crashfile, log_level=logging.DEBUG):

        self.binary = binary
        self.crashfile = crashfile
        self.log_level = log_level

        self.crashType = None
        self.log = get_logger('exploiter.py', log_level)
        
        self.src = []
    

    """
    New and init an emulator
    """
    def initEmulator(self, show_inst=False, symbolize=False, isTaint=False):

        emulator = Emulator(self.binary, 
                show_inst=show_inst, 
                show_output=False,
                symbolize=symbolize, 
                isTaint=isTaint, 
                log_level=self.log_level)

        emulator.initialize()
        data = open(self.crashfile).read()
        emulator.set_input(data)
        
        return emulator

    
    """
    Get crash type. Supported type includes:
        NO_CRASH, not any type of crash
        CONTROL_PC, pc address can be control by input
        SHELLCODE, is able to execute inputed shellcode
    """
    def getCrashType(self):

        if self.crashType:
            return self.crashType

        emulator = self.initEmulator()
        pc = emulator.getpc()

        try:
            while pc:
                pc = emulator.process()
            self.crashType = crash.NO_CRASH

        except IllegalPcException:
            self.log.info("Detecting crash info at " + hex(pc))
            self.src = emulator.getSrc()
            self.crash_pc = pc
            esp = emulator.getreg('esp') - 4
            self.dst = range(esp, esp + 4)
            self.crashType = crash.CONTROL_PC

        except IllegalInstException:
            self.crashType = crash.SHELLCODE

        return self.crashType
    

    """
    Get the list of memory address which cause program crash
    """
    def getCrashMemory(self):
        return self.dst


    """
    
    """
    def getControlMemory(self):
        pass

    """

    """
    def getControlShellcode(self):
        pass


    """
    Create input stream which can control eip to target value
    """
    def pcPayload(self, pc):

        if self.crashType != crash.CONTROL_PC:
            return False
        
        initInput = open(self.crashfile).read()
        solver = InputSolver(self.binary, self.getSrc(), self.crash_pc, initInput)
        answer = solver.solveValue(self.dst, pc)
        payload = self.createInput(answer)
        return answer
